---
status: accepted
---

opendevshop is a painfully simple, file-first project planner designed for humans and agents to coordinate work without turning planning into a chat log or turning the workspace into mush. The core bet is that planning becomes reliable for agents when intent, decisions, coordination structure, and actionables are separated into distinct layers, and when ambiguity and staleness are explicit states rather than implicit failure modes.

This project is an experiment in building a small, durable context network for one use case (project planning) that stays usable when agents are overloaded, have conflicting installed knowledge, or are operating near context-window limits.

The core move: constitution-as-log, everything else is compiled

The only human-authored, authoritative surface is an append-only constitutional log of entries (decisions + accepted contract answers). Everything else is derived and disposable, except for explicitly non-authoritative staging surfaces used to propose changes.

Receiptless by design: snapshots are the record

There is no separate receipts layer.

A successful publish produces an immutable snapshot directory. That snapshot is the durable record of "what was applied." Audit is done by diffing snapshots (or git history), not by reading a separate run log.

Each compiled file carries minimal stamps pointing to its origin (cursor + hashes + snapshot path). That is sufficient for provenance without introducing a second authoritative surface.

Apply is the gate

The system has a single integrity rule:
•	If the log cannot be safely applied into a new published snapshot, then the project is blocked and the system must emit explicit requests for missing information rather than guessing.

In other words: "what's next?" is answered only from a successfully published snapshot. If publish cannot happen, the correct output is NEEDS_INPUT (via a contract).

What we are building (v0 scope)

A file-first planning workspace where:
•	Humans and agents append constitutional entries into a log (no rewrites-in-place of truth).
•	When missing information blocks safe compilation, the system produces a contract file requesting that information in a tight, answerable form.
•	Humans answer contracts by editing the contract file and submitting it by moving it into a "complete" folder.
•	A reviewer agent promotes completed contracts into the constitutional log (rewriting only frontmatter; body meaning is preserved), or returns them for refinement with explicit revision notes.
•	An apply step consumes new log entries and publishes a new compiled snapshot containing the current kernel and deterministic selection views.
•	Work selection is driven by deterministic views (READY / NEEDS_INPUT / STALE / RECENT), not interpretive rereading.

Plans may exist later as coordination units, but are not required to prove the core loop.

Guiding principle: physics over templates

We won't enforce rigid authoring templates for the prose inside constitutional entries. Humans write naturally.

What we enforce is procedural physics:
•	Truth only changes by appending entries (or promoting submitted contracts into entries).
•	Entries are applied in order.
•	Compiled artifacts are stamped with what they were compiled from (cursor + hashes + snapshot path).
•	If the system cannot infer a safe change, it emits a contract (or contract refinement) rather than guessing.
•	Published compiled snapshots are treated as immutable coordination surfaces; changes happen by publishing a new snapshot, not by mutating the current one.

Tight interaction contract (v0)

Agents interacting with the user should produce only one of two top-level outcomes by default:
•	APPLY_OK: new cursor + snapshot path + snapshot hash (+ minimal changed-path summary).
•	NEEDS_INPUT: one contract path (+ reason code).

Optional elaboration exists, but is not part of the coordination substrate.

Layers (altitudes)

Authoritative (durable, append-only)

1. Constitutional log: ordered entries (decisions + accepted contract answers). This is the constitution.

Non-authoritative (human-editable, not executable)
2. Workbench memos/RFCs: a dumping ground for potentially useful future context. Referencable, but never drives behavior unless explicitly promoted via a decision/contract. Minimal envelope, freeform body.

Derived (disposable/regeneratable, non-human-editable)
3. Kernel view (this file): the current compiled narrative of intent, constraints, success, risks, non-goals, and open questions.
4. Tasks: actionables with dependencies and state, represented as compiled artifacts.
5. Views: generated READY / NEEDS_INPUT / STALE / RECENT summaries for deterministic selection and navigation.
6. Snapshots: published, immutable compiled directories; the primary audit surface (diff snapshots to understand change).

Branchless branching: proposal queue + serialized apply

We do not rely on git branches for safety.

Instead we use a non-authoritative proposal queue in the repo, and a single serialized apply/publish step that decides what becomes truth.

•	Workers and build agents write proposals (diffs + proposed log entries/contracts) into a proposals directory.
•	Nothing in proposals is authoritative; proposals are inputs awaiting acceptance.
•	The reviewer/apply step is serialized. It chooses which proposal(s) to accept, appends the corresponding constitutional entry/entries, applies code diffs if relevant, and publishes a new snapshot.
•	If proposals cannot be safely accepted, the system emits a contract (NEEDS_INPUT) rather than "half applying" or silently guessing.

This gives "branch-like" safety without branches: many parallel ideas, one linear truth.

Tasks: strict responsibility split (single file, no mush)

Each task is one file with a strict split of responsibility:

•	Task body: planner-owned, derived.
– The body is compiled from the constitution (and relevant accepted contracts).
– It contains the semantic meaning: goal, acceptance, dependencies, rationale, derived notes.
– It is not edited by workers.

•	Task frontmatter: worker-owned live state (plus planner-owned compiled fields).
– Frontmatter is split into explicit namespaces so responsibilities never overlap.

Example conceptual split (not a rigid schema, just "physics"):
•	frontmatter.task_* (planner/compiler writes; derived from constitution; safe inputs to deterministic READY)
•	frontmatter.live_* (workers write; coordination signals; not used to compute READY)

Workers may edit only `live_*` fields to register progress for other agents to see (claiming, in-progress notes, heartbeat, current proposal id, last run outcome, etc.). Planners/compilers may rewrite body and `task_*` fields during publish.

This stays "not mush" because:
•	The meaning remains in the body (semantic hash from body alone).
•	The authoritative state that drives READY comes from the constitution and compiler-owned fields.
•	Worker-written state is explicitly live/coordination metadata, not truth.

Deterministic READY stays true even with parallel workers: READY is computed from the published snapshot's derived fields, not from live edits.

FIX (task-state determinism)

Task files are derived artifacts with a split surface:
•	Meaning: body is compiled from a task event stream in the constitution (create/refine/complete/add_dependency/resolve_dependency, etc.).
•	Truth: completion/dependency resolution is recorded by appending entries (or promoting contracts) and republishing a snapshot.
•	Live progress: workers can update live frontmatter to reduce duplication and improve visibility, but those fields do not change what is READY.

Contract workflow (no chat, no log spam)

Contracts are files with explicit questions and typed expectations where useful. Humans do not answer by chat; they answer by editing the contract file and submitting it.

A reviewer agent then:
•	Promotes the submitted contract into the constitutional log by rewriting only frontmatter, OR
•	Returns it with explicit refinement requests.

This keeps the constitution as the only authoritative surface while keeping human interaction on a single, reviewable artifact.

Multi-agent reality (without orchestration theater)

Multiple agents can operate in parallel, but they do not coordinate by rereading mutable derived state as truth.

•	Planner agents derive tasks and views at publish time and anchor selection to the published snapshot.
•	Worker agents pick tasks from READY in the snapshot and report outcomes as proposals (diff + proposed entry/contract).
•	Worker agents may also write live frontmatter progress to help other workers avoid collisions, but this is explicitly non-authoritative.

Compilation/publish is the only step that needs serialization; parallelism happens everywhere else.

Shared understanding comes from a published snapshot, not from shared conversation state.

Stamps, hashes, and portability

Every file is conceptually split into:
•	A portable markdown body (meaning),
•	A metadata envelope for indexing, linking, routing, and bookkeeping.

Semantic hashing is computed from the body alone. Meaning must live in the body to participate in invalidation and provenance.

Compiled artifacts stamp:
•	The log cursor and log semantic hash they were compiled from,
•	The published snapshot path,
•	The compiler version (so diffs can distinguish "meaning change" from "compiler change").

Ambiguity and staleness as first-class states

When the system cannot safely proceed, it produces an inbox artifact (contract) that requests missing information in a tight, answerable form. Downstream compiled artifacts block on missing contracts, failed apply, or unresolved ambiguity.

Staleness is computed, not manually maintained: when upstream meaning changes, affected compiled regions are treated as stale until the next successful publish produces an updated snapshot.

Scoped decisions (to avoid kernel bloat)

Not all decisions are kernel-level.

A decision may target:
•	Project scope (kernel-level meaning),
•	A task (implementation choices, constraints, acceptance details).

Kernel-level decisions amend the project narrative. Task-level decisions refine execution without inflating the kernel. If a "small" choice later proves architectural, a later higher-scope decision supersedes it.

Success (falsifiable)

opendevshop is successful if, for a non-trivial project, it can repeatedly produce a "what's next?" view that is:
•	Deterministic at the view layer: the same published snapshot yields the same READY set.
•	Safe: it refuses to proceed on ambiguous or stale prerequisites rather than silently guessing.
•	Low-maintenance: humans append decisions / submit contracts; they do not hand-curate task truth to keep coherence.
•	Multi-agent coherent: parallel agents do not create mixed derived states because coordination is anchored to a published snapshot.

Concrete test:
•	Dogfood on a medium project over 20–40 task transitions.
•	Verify READY remains trustworthy, ambiguity appears as explicit NEEDS_INPUT, and changes cause predictable recompile + republish.
•	Verify agents never need to "reinterpret the past" because the published snapshot is the coordination surface.
•	Verify "why did READY change?" is answerable by diffing snapshots.

Constraints
•	Painfully simple: files, minimal moving parts, minimal hidden state.
•	Diffable and reviewable: authoritative truth is append-only.
•	Avoid relying on "agent persuasion" as the primary reliability strategy. Progressive disclosure is fine, but must be anchored in explicit artifacts and deterministic selection rules.
•	No background watchers required; prefer explicit/on-demand apply and publish.

Non-goals
•	Not a full Jira/Linear replacement.
•	Not a general-purpose knowledge graph.
•	Not an attempt to standardize a global ontology.
•	Not a guarantee of correct reasoning—this is about reducing ambiguity, drift, and silent contradiction in the planning substrate.

Open questions
•	What is the minimal set of physics checks that makes apply safe without making authoring brittle?
•	What is the minimal task schema that still supports deterministic READY selection?
•	What are the simplest invalidation semantics that avoid thrash while preserving safety?
•	Where is the right boundary between kernel-level meaning and task-scoped decisions?
•	How should apply conflicts be represented so resolution stays simple (contracts, not debates)?
•	What is the promotion contract for workbench memos/RFCs (how ideas move into commitments without becoming shadow-truth)?
•	Do we ever need a tiny per-snapshot manifest (inside snapshots/) to summarize "writes + diagnostics," or are snapshot diffs sufficient?

Kernel decomposition (next version; this is the last single-file kernel)

A single kernel narrative will bloat and truncate. Next version, "kernel" becomes a directory of concern-scoped kernel files, each with a generated summary, plus a stitched BRIEF.

Target shape:
•	kernel/00_intent.md (+ summary)
•	kernel/10_physics.md (+ summary)
•	kernel/20_contracts.md (+ summary)
•	kernel/30_tasks.md (+ summary)
•	kernel/40_proposals.md (+ summary)
•	kernel/50_multi_agent.md (+ summary)
•	kernel/90_open_questions.md (+ summary)
•	kernel/BRIEF.md (stitched from summaries; default agent load)
•	kernel/FULL.md (stitched full; rarely loaded)

This keeps "kernel" canonical while making retrieval and altitude control explicit.

Current thesis

If commitments and missing information are captured as append-only constitutional entries (with contracts filled by humans and promoted by agents), proposals allow safe parallelism without branches, and everything else is a stamped, disposable compiled view published as immutable snapshots (kernel + tasks + READY), then agents can plan and execute reliably under context pressure while minimizing drift, ambiguity, and interpretive rereads—even as multiple agent roles interact through explicit lifecycle events.
