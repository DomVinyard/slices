---
tt:
  v: "1"
  id: 01JWAGGLE023
  created_at: "2023-09-08T09:30:00Z"
  title: "Tail Wag Analyzer"
  summary: "Measures wag frequency to gauge destination happiness"
  kind: pointer
  body:
    type: code
    code:
      lang: python
      extension: py
  contract:
    purpose: "Pointer to tail wag analysis service"
    exclude: ["calibration data", "breed-specific models"]
    format: "Code reference with signal processing pipeline"
    write: replace
  links:
    - rel: parent
      to: 01JWAGGLE002
      label: "Architecture"
    - rel: implements
      to: 01JWAGGLE012
      label: "Destination Learning ADR"
    - rel: references
      to: 01JWAGGLE005
      label: "Popular Destinations"
---

# Tail Wag Analyzer

**Location:** `services/tail-wag/`

## Key Files

- `services/tail-wag/analyzer.py` - Core wag analysis
- `services/tail-wag/scoring.py` - Wag score calculation
- `services/tail-wag/streaming.py` - Real-time wag streaming
- `collar-firmware/src/accelerometer.c` - On-device preprocessing

## Wag Analysis

```python
# analyzer.py

import numpy as np
from scipy import signal
from dataclasses import dataclass

@dataclass
class WagAnalysis:
    frequency_hz: float      # Wags per second
    amplitude: float         # Wag width (0-1 normalized)
    duration_seconds: float  # How long wagging lasted
    pattern: str            # 'excited', 'happy', 'nervous', 'none'
    score: float            # 0-10 happiness score

class TailWagAnalyzer:
    
    def analyze(self, accel_data: np.ndarray, sample_rate: int = 100) -> WagAnalysis:
        """
        Analyze accelerometer data to extract wag characteristics.
        
        accel_data: Array of [x, y, z] accelerometer readings
        sample_rate: Samples per second (collar sends 100Hz)
        """
        # Extract lateral movement (side-to-side wagging)
        lateral = accel_data[:, 0]  # X-axis is lateral on collar
        
        # Remove baseline (dog walking movement)
        lateral_detrended = signal.detrend(lateral)
        
        # Find wag frequency using FFT
        freqs, psd = signal.welch(lateral_detrended, fs=sample_rate)
        
        # Dog wags are typically 1-10 Hz
        wag_band = (freqs >= 1) & (freqs <= 10)
        peak_idx = np.argmax(psd[wag_band])
        wag_freq = freqs[wag_band][peak_idx]
        
        # Calculate amplitude
        amplitude = np.std(lateral_detrended)
        
        # Determine pattern
        pattern = self._classify_pattern(wag_freq, amplitude)
        
        # Calculate happiness score
        score = self._calculate_score(wag_freq, amplitude, pattern)
        
        return WagAnalysis(
            frequency_hz=wag_freq,
            amplitude=amplitude,
            duration_seconds=len(accel_data) / sample_rate,
            pattern=pattern,
            score=score
        )
    
    def _classify_pattern(self, freq: float, amplitude: float) -> str:
        if amplitude < 0.1:
            return 'none'
        elif freq > 5 and amplitude > 0.5:
            return 'excited'
        elif freq > 3:
            return 'happy'
        elif freq < 2 and amplitude > 0.3:
            return 'nervous'  # Slow, wide wags can indicate uncertainty
        else:
            return 'happy'
    
    def _calculate_score(self, freq: float, amplitude: float, pattern: str) -> float:
        if pattern == 'none':
            return 0.0
        
        # Base score from frequency (faster = happier, usually)
        freq_score = min(freq / 6.0, 1.0) * 5  # Max 5 points from frequency
        
        # Amplitude bonus (bigger wags = more enthusiasm)
        amp_score = min(amplitude / 0.6, 1.0) * 3  # Max 3 points
        
        # Pattern bonus
        pattern_bonus = {
            'excited': 2.0,
            'happy': 1.5,
            'nervous': 0.0,
            'none': 0.0
        }
        
        return min(freq_score + amp_score + pattern_bonus[pattern], 10.0)
```

## Real-Time Streaming

```python
# streaming.py

import asyncio
from collections import deque

class WagStreamProcessor:
    """Processes streaming wag data during rides."""
    
    def __init__(self, ride_id: str):
        self.ride_id = ride_id
        self.analyzer = TailWagAnalyzer()
        self.buffer = deque(maxlen=500)  # 5 seconds at 100Hz
        self.current_score = 0.0
    
    async def process_sample(self, accel_reading: list[float]):
        """Called for each accelerometer reading from collar."""
        self.buffer.append(accel_reading)
        
        # Analyze every 100 samples (1 second)
        if len(self.buffer) == 500 and len(self.buffer) % 100 == 0:
            data = np.array(list(self.buffer))
            analysis = self.analyzer.analyze(data)
            
            # Emit to human's app
            await self.emit_wag_update(analysis)
            
            # Store for destination learning
            await self.store_wag_data(analysis)
    
    async def emit_wag_update(self, analysis: WagAnalysis):
        """Send real-time wag score to human's app."""
        await websocket_emit(
            room=f"ride_{self.ride_id}",
            event="wag_update",
            data={
                "score": analysis.score,
                "pattern": analysis.pattern,
                "timestamp": datetime.utcnow().isoformat()
            }
        )
```

## Breed Calibration

```python
# Different breeds wag differently

BREED_CALIBRATION = {
    "golden_retriever": {"freq_mult": 1.0, "amp_mult": 1.0},
    "bulldog": {"freq_mult": 0.7, "amp_mult": 0.6},  # Slower, smaller wags
    "husky": {"freq_mult": 1.1, "amp_mult": 1.2},   # Dramatic waggers
    "greyhound": {"freq_mult": 0.9, "amp_mult": 0.8},
    "corgi": {"freq_mult": 1.3, "amp_mult": 0.5},   # Fast but stubby
    "great_dane": {"freq_mult": 0.8, "amp_mult": 1.5},  # Slow but big
}

def calibrate_for_breed(analysis: WagAnalysis, breed: str) -> WagAnalysis:
    """Adjust scores based on breed-typical wag patterns."""
    cal = BREED_CALIBRATION.get(breed, {"freq_mult": 1.0, "amp_mult": 1.0})
    # Apply calibration to normalize across breeds
    ...
```
